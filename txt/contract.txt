// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";

contract BetBrasil is Ownable {
    using SafeMath for uint256;
    
    // Estrutura de uma aposta
    struct Aposta {
        address jogador;
        uint256[5] palpites; // 5 nÃºmeros entre 0 e 624 (1/1 a 25/25)
        uint256 rodada;
        bool pago;
    }
    
    // Estrutura de uma rodada
    struct Rodada {
        uint256 inicio;
        uint256 fim;
        uint256 totalApostas;
        uint256 valorArrecadado;
        bool resultadosDefinidos;
        uint256[5] resultados; // Resultados convertidos (ex: [124, 342, 500, 23, 88])
        mapping(uint256 => Aposta) apostas;
    }
    
    // ConfiguraÃ§Ãµes
    mapping(uint256 => Rodada) public rodadas;
    uint256 public rodadaAtual;
    
    uint256 public constant VALOR_APOSTA = 0.00033 ether; // ~R$5,00 (ajustar conforme ETH)
    uint256 public constant PERCENTUAL_PREMIO = 45; // 45% do valor arrecadado
    uint256[5] public distribuicaoPremios = [50, 25, 12, 8, 5]; // 5, 4, 3, 2, 1 acertos
    
    // Eventos (para o frontend)
    event ApostaFeita(address jogador, uint256 rodada, uint256[5] palpites);
    event RodadaFechada(uint256 rodada);
    event ResultadosDefinidos(uint256 rodada, uint256[5] resultados);
    event PremioRecebido(address jogador, uint256 rodada, uint256 valor);
    
    constructor() {
        rodadaAtual = 1;
        rodadas[rodadaAtual].inicio = block.timestamp;
        rodadas[rodadaAtual].fim = block.timestamp + 1 days; // Encerra Ã s 17h (ajustar)
    }
    
    // **FAZER UMA APOSTA** (Jogador escolhe 5 nÃºmeros de 0 a 624)
    function apostar(uint256[5] calldata palpites) external payable {
        require(msg.value == VALOR_APOSTA, "Valor da aposta errado, parÃ§a!");
        require(block.timestamp < rodadas[rodadaAtual].fim, "Rodada fechada, tente na prÃ³xima!");

        // Verifica se os palpites sÃ£o vÃ¡lidos (0 a 624)
        for (uint i = 0; i < 5; i++) {
            require(palpites[i] < 625, "Palpite invÃ¡lido, meu rei! Use nÃºmeros de 0 a 624.");
        }

        // Registra a aposta
        uint256 idAposta = rodadas[rodadaAtual].totalApostas;
        rodadas[rodadaAtual].apostas[idAposta] = Aposta({
            jogador: msg.sender,
            palpites: palpites,
            rodada: rodadaAtual,
            pago: false
        });

        rodadas[rodadaAtual].totalApostas++;
        rodadas[rodadaAtual].valorArrecadado += msg.value;

        emit ApostaFeita(msg.sender, rodadaAtual, palpites);
    }
    
    // **DEFINIR RESULTADOS** (Owner insere os 5 prÃªmios da Loteria Federal)
    function definirResultados(uint256[5] calldata resultadosFederal) external onlyOwner {
        require(!rodadas[rodadaAtual].resultadosDefinidos, "Resultados jÃ¡ lanÃ§ados, chefia!");

        // Converte os resultados (ex: 4567 -> 5/17)
        uint256[5] memory resultadosConvertidos;
        for (uint i = 0; i < 5; i++) {
            uint256 dezenas = resultadosFederal[i];
            uint256 primeiroNum = (dezenas / 100) % 100; // PenÃºltimos 2 dÃ­gitos
            uint256 segundoNum = dezenas % 100;          // Ãšltimos 2 dÃ­gitos
            
            // Ajusta para 1-25 (Jogo do Bicho)
            primeiroNum = (primeiroNum % 25) + 1;
            segundoNum = (segundoNum % 25) + 1;
            
            // Converte para 0-624 (matriz 25x25)
            resultadosConvertidos[i] = ((primeiroNum - 1) * 25) + (segundoNum - 1);
        }

        rodadas[rodadaAtual].resultados = resultadosConvertidos;
        rodadas[rodadaAtual].resultadosDefinidos = true;

        emit ResultadosDefinidos(rodadaAtual, resultadosConvertidos);
    }
    
    // **RECLAMAR PRÃŠMIO** (Jogador verifica se ganhou)
    function reclamarPremio(uint256 rodada, uint256 idAposta) external {
        require(rodada < rodadaAtual, "Essa rodada ainda tÃ¡ rolando, parceiro!");
        require(rodadas[rodada].resultadosDefinidos, "Resultados nÃ£o saÃ­ram ainda!");
        require(!rodadas[rodada].apostas[idAposta].pago, "PrÃªmio jÃ¡ foi sacado, campeÃ£o!");
        require(rodadas[rodada].apostas[idAposta].jogador == msg.sender, "VocÃª nÃ£o fez essa aposta!");

        Aposta storage aposta = rodadas[rodada].apostas[idAposta];
        uint256 acertos = 0;

        // Conta quantos palpites acertaram
        for (uint i = 0; i < 5; i++) {
            for (uint j = 0; j < 5; j++) {
                if (aposta.palpites[i] == rodadas[rodada].resultados[j]) {
                    acertos++;
                    break;
                }
            }
        }

        require(acertos > 0, "NÃ£o foi dessa vez, amigÃ£o! Tente novamente.");

        // Calcula o prÃªmio (com regra de rollover)
        uint256 valorPremioTotal = rodadas[rodada].valorArrecadado.mul(PERCENTUAL_PREMIO).div(100);
        uint256 premio = valorPremioTotal.mul(distribuicaoPremios[acertos-1]).div(100);

        // Marca como pago e transfere
        aposta.pago = true;
        payable(msg.sender).transfer(premio);

        emit PremioRecebido(msg.sender, rodada, premio);
    }
    
    // **FECHAR RODADA** (Owner encerra apostas)
    function fecharRodada() external onlyOwner {
        require(block.timestamp >= rodadas[rodadaAtual].fim, "Ainda nÃ£o acabou o prazo!");

        emit RodadaFechada(rodadaAtual);

        // PrÃ³xima rodada comeÃ§a depois do sorteio
        rodadaAtual++;
        rodadas[rodadaAtual].inicio = block.timestamp + 4 hours; // Reabre Ã s 21h
        rodadas[rodadaAtual].fim = rodadas[rodadaAtual].inicio + 1 days;
    }
    
    // **SACAR ROYALTIES** (Owner recebe 55% do valor)
    function sacarRoyalties() external onlyOwner {
        uint256 saldo = address(this).balance;
        uint256 royalties = saldo.mul(55).div(100);
        payable(owner()).transfer(royalties);
    }

    // **FUNÃ‡Ã•ES AUXILIARES** (Para o frontend)
    function getAnimaisDoNumero(uint256 numero) public pure returns (string memory, string memory) {
        require(numero < 625, "NÃºmero invÃ¡lido, meu consagrado!");
        
        uint256 primeiro = (numero / 25) + 1;
        uint256 segundo = (numero % 25) + 1;
        
        string[25] memory bichos = [
            "Avestruz", "Ãguia", "Burro", "Borboleta", "Cachorro",
            "Cabra", "Carneiro", "Camelo", "Cobra", "Coelho",
            "Cavalo", "Elefante", "Galo", "Gato", "JacarÃ©",
            "LeÃ£o", "Macaco", "Porco", "PavÃ£o", "Peru",
            "Touro", "Tigre", "Urso", "Veado", "Vaca"
        ];
        
        return (bichos[primeiro-1], bichos[segundo-1]);
    }
}